enum EventType {
  Requested
  Initialized
  Finalized
  Migrated
}

interface ActivityData @key(fields: "id") {
  id: ID!
  depositOwner: DepositOwner!
  events: [Event!]
  bitcoinTransactionId: String
}

type DepositOwner @entity {
  # Id is the ethereum address of the account.
  id: ID!
  activities: [ActivityData!] @derivedFrom(field: "depositOwner")
}

type Deposit implements ActivityData @entity {
  id: ID!
  depositOwner: DepositOwner!
  events: [Event!] @derivedFrom(field: "activity")
  initialDepositAmount: BigInt!
  bridgedAmount: BigInt
  depositorFee: BigInt
  amountToDeposit: BigInt
  referral: Int
  bitcoinTransactionId: String
}

type Withdraw implements ActivityData @entity {
  id: ID!
  depositOwner: DepositOwner!
  events: [Event!] @derivedFrom(field: "activity")
  amount: BigInt
  requestedAmount: BigInt
  amountToRedeem: BigInt
  bitcoinTransactionId: String
  redeemerOutputScript: String
}

type Event @entity {
  # Id is the transaction hash.
  id: ID!
  timestamp: BigInt!
  activity: ActivityData
  type: EventType!
}

# There can be multiple withdraw entities with the same redemption key, but only
# one redemption can be in the "pending" state. As a result, there can be only
# one redemption with the same redemption key and the same withdraw ID. It
# means that on the tBTC side first, the redemption is initialized and a
# redemption key is generated. Until this redemption is processed (i.e.,
# finalized), it is not possible to create another redemption with the same key.
# To determine whether a given redemption has been processed, we track the
# `submitRedemptionProofCall` function from the `TbtcBridge` contract. However,
# the data emitted by this function does not allow us to link the redemption to
# the withdraw ID generated by the contract. Therefore, we need to figure out a
# way to associate the withdraw ID with the redemption key â€” and this entity
# serves that purpose.
type RedemptionKeyToPendingWithdrawal @entity {
  # keccak256(keccak256(redeemerOutputScript) | walletPubKeyHash)
  id: ID!
  withdrawId: String
}

type RedemptionsCompletedEvent @entity {
  # wallet public key hash + block hash
  id: ID!
  redemptionTxHash: Bytes!
}
