// TOOD: Update imports
import { BitcoinRedeemer as BitcoinRedeemerTypechain } from "@acre-btc/contracts/typechain/contracts/BitcoinRedeemer"
import SepoliaBitcoinRedeemer from "@acre-btc/contracts/deployments/sepolia/BitcoinRedeemer.json"
import MainnetBitcoinRedeemer from "@acre-btc/contracts/deployments/mainnet/BitcoinRedeemer.json"

import { ethers } from "ethers"
import {
  EthersContractConfig,
  EthersContractDeployment,
  EthersContractWrapper,
} from "./contract"
import { ChainIdentifier, BitcoinRedeemer, WithdrawalFees } from "../contracts"
import { EthereumNetwork } from "./network"
import TbtcBridge from "./tbtc-bridge"
import { Hex } from "../utils"

type TbtcBridgeRedemptionParameters = {
  redemptionTreasuryFeeDivisor: bigint
}

type BitcoinRedeemerCache = {
  tbtcBridgeRedemptionParameters: TbtcBridgeRedemptionParameters | undefined
}

export default class EthereumBitcoinRedeemer
  // @ts-expect-error TODO: Figure out why type generated by typechain does not
  // satisfy the constraint `Contract`. Error: `Property '[internal]' is missing
  // in type 'BitcoinRedeemer' but required in type 'Contract'`.
  extends EthersContractWrapper<BitcoinRedeemerTypechain>
  implements BitcoinRedeemer
{
  #cache: BitcoinRedeemerCache

  #tbtcBridge: TbtcBridge | undefined

  constructor(config: EthersContractConfig, network: EthereumNetwork) {
    let artifact: EthersContractDeployment

    switch (network) {
      case "sepolia":
        artifact = {
          ...SepoliaBitcoinRedeemer,
          address: "0x3f836b84c7A46Ae733F89dE26226ce674fc68Bd7",
        }
        break
      case "mainnet":
        artifact = MainnetBitcoinRedeemer
        break
      default:
        throw new Error("Unsupported network")
    }

    super(config, artifact)
    this.#cache = {
      tbtcBridgeRedemptionParameters: undefined,
    }
  }

  setTbtcContracts({ tbtcBridge }: { tbtcBridge: TbtcBridge }): void {
    this.#tbtcBridge = tbtcBridge
  }

  /**
   * @see {BitcoinRedeemer#getChainIdentifier}
   */
  getChainIdentifier(): ChainIdentifier {
    return this.getAddress()
  }

  /**
   * @see {BitcoinRedeemer#calculateWithdrawalFee}
   */
  async calculateWithdrawalFee(
    amountToWithdraw: bigint,
  ): Promise<WithdrawalFees> {
    const { redemptionTreasuryFeeDivisor } =
      await this.#getTbtcBridgeRedemptionParameters()

    const treasuryFee =
      redemptionTreasuryFeeDivisor > 0
        ? amountToWithdraw / redemptionTreasuryFeeDivisor
        : 0n

    return {
      tbtc: {
        treasuryFee,
      },
    }
  }

  // TODO: Consider exposing it from tBTC SDK.
  async #getTbtcBridgeRedemptionParameters(): Promise<TbtcBridgeRedemptionParameters> {
    if (this.#cache.tbtcBridgeRedemptionParameters) {
      return this.#cache.tbtcBridgeRedemptionParameters
    }

    if (!this.#tbtcBridge) {
      throw new Error("tBTC contracts not set")
    }

    const { redemptionTreasuryFeeDivisor } =
      await this.#tbtcBridge.redemptionParameters()

    this.#cache.tbtcBridgeRedemptionParameters = {
      redemptionTreasuryFeeDivisor,
    }
    return this.#cache.tbtcBridgeRedemptionParameters
  }

  /**
   * @see {BitcoinRedeemer#encodeReceiveApprovalExtraData}
   */
  // eslint-disable-next-line class-methods-use-this
  encodeReceiveApprovalExtraData(
    redeemer: ChainIdentifier,
    redeemerOutputScript: Hex,
  ): Hex {
    // We only need encode `redeemer` and `redeemerOutputScript`. Other values
    // can be empty because the are not used in the contract.
    return Hex.from(
      ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes20", "bytes32", "uint32", "uint64", "bytes"],
        [
          `0x${redeemer.identifierHex}`,
          // The Ethereum address is 20 bytes so we can use it as "empty" ` bytes20`
          // type.
          ethers.ZeroAddress,
          ethers.encodeBytes32String(""),
          0,
          0,
          redeemerOutputScript.toPrefixedString(),
        ],
      ),
    )
  }
}
