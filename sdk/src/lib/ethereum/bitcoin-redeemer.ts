import { BitcoinRedeemerV2 as BitcoinRedeemerTypechain } from "@acre-btc/contracts/typechain/contracts/BitcoinRedeemerV2"
import SepoliaBitcoinRedeemer from "@acre-btc/contracts/deployments/sepolia/BitcoinRedeemerV2.json"
import MainnetBitcoinRedeemer from "@acre-btc/contracts/deployments/mainnet/BitcoinRedeemer.json"

import { ethers } from "ethers"
import {
  EthereumContractRunner,
  EthersContractConfig,
  EthersContractDeployment,
  EthersContractWrapper,
} from "./contract"
import {
  ChainIdentifier,
  BitcoinRedeemer,
  RedeemerWithdrawalFees,
} from "../contracts"
import { EthereumNetwork } from "./network"
import TbtcBridge from "./tbtc-bridge"
import { Hex } from "../utils"

type TbtcBridgeRedemptionParameters = {
  redemptionTreasuryFeeDivisor: bigint
}

type BitcoinRedeemerCache = {
  tbtcBridgeRedemptionParameters: TbtcBridgeRedemptionParameters | undefined
}

export default class EthereumBitcoinRedeemer
  // @ts-expect-error TODO: Figure out why type generated by typechain does not
  // satisfy the constraint `Contract`. Error: `Property '[internal]' is missing
  // in type 'BitcoinRedeemer' but required in type 'Contract'`.
  extends EthersContractWrapper<BitcoinRedeemerTypechain>
  implements BitcoinRedeemer
{
  #cache: BitcoinRedeemerCache

  #tbtcBridge: TbtcBridge | undefined

  #runner: EthereumContractRunner

  constructor(config: EthersContractConfig, network: EthereumNetwork) {
    let artifact: EthersContractDeployment

    switch (network) {
      case "sepolia":
        artifact = {
          ...SepoliaBitcoinRedeemer,
          address: "0xE1d25025835A89C93d56a029C80699BE056584d2",
        }
        break
      case "mainnet":
        // TODO: set the new mainnet address
        artifact = MainnetBitcoinRedeemer
        break
      default:
        throw new Error("Unsupported network")
    }

    super(config, artifact)
    this.#runner = config.runner
    this.#cache = {
      tbtcBridgeRedemptionParameters: undefined,
    }
  }

  setTbtcContracts({ tbtcBridge }: { tbtcBridge: TbtcBridge }): void {
    this.#tbtcBridge = tbtcBridge
  }

  /**
   * @see {BitcoinRedeemer#getChainIdentifier}
   */
  getChainIdentifier(): ChainIdentifier {
    return this.getAddress()
  }

  /**
   * @see {BitcoinRedeemer#calculateWithdrawalFee}
   */
  async calculateWithdrawalFee(
    amountToWithdraw: bigint,
  ): Promise<RedeemerWithdrawalFees> {
    const { redemptionTreasuryFeeDivisor } =
      await this.#getTbtcBridgeRedemptionParameters()

    const treasuryFee =
      redemptionTreasuryFeeDivisor > 0
        ? amountToWithdraw / redemptionTreasuryFeeDivisor
        : 0n

    return {
      tbtc: {
        treasuryFee,
      },
    }
  }

  // TODO: Consider exposing it from tBTC SDK.
  async #getTbtcBridgeRedemptionParameters(): Promise<TbtcBridgeRedemptionParameters> {
    if (this.#cache.tbtcBridgeRedemptionParameters) {
      return this.#cache.tbtcBridgeRedemptionParameters
    }

    if (!this.#tbtcBridge) {
      throw new Error("tBTC contracts not set")
    }

    const { redemptionTreasuryFeeDivisor } =
      await this.#tbtcBridge.redemptionParameters()

    this.#cache.tbtcBridgeRedemptionParameters = {
      redemptionTreasuryFeeDivisor,
    }
    return this.#cache.tbtcBridgeRedemptionParameters
  }

  /**
   * @see {BitcoinRedeemer#encodeReceiveApprovalExtraData}
   */
  // eslint-disable-next-line class-methods-use-this
  encodeReceiveApprovalExtraData(
    redeemer: ChainIdentifier,
    redeemerOutputScript: Hex,
  ): Hex {
    // We only need encode `redeemer` and `redeemerOutputScript`. Other values
    // can be empty because the are not used in the contract.
    return Hex.from(
      ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes20", "bytes32", "uint32", "uint64", "bytes"],
        [
          `0x${redeemer.identifierHex}`,
          // The Ethereum address is 20 bytes so we can use it as "empty" ` bytes20`
          // type.
          ethers.ZeroAddress,
          ethers.encodeBytes32String(""),
          0,
          0,
          redeemerOutputScript.toPrefixedString(),
        ],
      ),
    )
  }

  /**
   * @see {BitcoinRedeemer#findRedemptionRequestIdFromTransaction}
   */
  async findRedemptionRequestIdFromTransaction(
    transactionHash: Hex,
  ): Promise<bigint> {
    const receipt = await this.#runner.provider?.getTransactionReceipt(
      transactionHash.toPrefixedString(),
    )

    if (!receipt)
      throw new Error(
        `Cannot find the redemption request id. Transaction with hash ${transactionHash.toPrefixedString()} not found`,
      )

    const eventTopic = this.instance.interface.getEvent(
      "RedemptionRequested",
    ).topicHash

    // We assume only one redemption was requested in this transaction.
    const log = receipt.logs.find(
      (receiptLog) => receiptLog.topics[0] === eventTopic,
    )

    if (!log)
      throw new Error(
        "Cannot find the redemption request id. The RedemptionRequested event not found",
      )

    // @ts-expect-error Something is off with types.
    const parsedLog = this.instance.interface.parseLog(log)

    if (!parsedLog)
      throw new Error("Cannot find the redemption request id. Cannot parse log")

    return parsedLog.args[1] as bigint
  }
}
