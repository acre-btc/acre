import { packRevealDepositParameters } from "@keep-network/tbtc-v2.ts"
import { BitcoinDepositorV2 as BitcoinDepositorTypechain } from "@acre-btc/contracts/typechain/contracts/BitcoinDepositorV2.sol"
import SepoliaBitcoinDepositor from "@acre-btc/contracts/deployments/sepolia/BitcoinDepositorV2.json"
import MainnetBitcoinDepositor from "@acre-btc/contracts/deployments/mainnet/BitcoinDepositorV2.json"

import {
  ZeroAddress,
  dataSlice,
  getAddress,
  isAddress,
  solidityPacked,
  zeroPadBytes,
} from "ethers"
import {
  ChainIdentifier,
  DecodedExtraData,
  BitcoinDepositor,
  DepositFees,
} from "../contracts"

import { EthereumAddress } from "./address"
import {
  EthersContractConfig,
  EthersContractDeployment,
  EthersContractWrapper,
} from "./contract"
import { Hex, fromSatoshi } from "../utils"
import { EthereumNetwork } from "./network"
import TbtcBridge from "./tbtc-bridge"
import TbtcVault from "./tbtc-vault"
import ERC20Token from "./erc20-token"

type TbtcBridgeMintingParameters = {
  depositTreasuryFeeDivisor: bigint
  depositTxMaxFee: bigint
  optimisticMintingFeeDivisor: bigint
}

type BitcoinDepositorCache = {
  tbtcBridgeMintingParameters: TbtcBridgeMintingParameters | undefined
  depositorFeeDivisor: bigint | undefined
  feesReimbursementPool: EthereumAddress | undefined
}

/**
 * Ethereum implementation of the BitcoinDepositor.
 */
class EthereumBitcoinDepositor
  // @ts-expect-error TODO: Figure out why type generated by typechain does not
  // satisfy the constraint `Contract`. Error: `Property '[internal]' is missing
  // in type 'BitcoinDepositor' but required in type 'Contract'`.
  extends EthersContractWrapper<BitcoinDepositorTypechain>
  implements BitcoinDepositor
{
  #cache: BitcoinDepositorCache

  #tbtcBridge: TbtcBridge | undefined

  #tbtcVault: TbtcVault | undefined

  #tbtcToken: ERC20Token | undefined

  constructor(config: EthersContractConfig, network: EthereumNetwork) {
    let artifact: EthersContractDeployment

    switch (network) {
      case "sepolia":
        artifact = SepoliaBitcoinDepositor
        break
      case "mainnet":
        artifact = MainnetBitcoinDepositor
        break
      default:
        throw new Error("Unsupported network")
    }

    super(config, artifact)
    this.#cache = {
      tbtcBridgeMintingParameters: undefined,
      depositorFeeDivisor: undefined,
      feesReimbursementPool: undefined,
    }
  }

  setTbtcContracts({
    tbtcBridge,
    tbtcVault,
    tbtcToken,
  }: {
    tbtcBridge: TbtcBridge
    tbtcVault: TbtcVault
    tbtcToken: ERC20Token
  }): void {
    this.#tbtcBridge = tbtcBridge
    this.#tbtcVault = tbtcVault
    this.#tbtcToken = tbtcToken
  }

  /**
   * @see {BitcoinDepositor#getChainIdentifier}
   */
  getChainIdentifier(): ChainIdentifier {
    return this.getAddress()
  }

  /**
   * @see {BitcoinDepositor#getTbtcVaultChainIdentifier}
   */
  async getTbtcVaultChainIdentifier(): Promise<ChainIdentifier> {
    const vault = await this.instance.tbtcVault()

    return EthereumAddress.from(vault)
  }

  // eslint-disable-next-line class-methods-use-this
  revealDeposit(): Promise<Hex> {
    throw new Error("Unsupported")
  }

  /**
   * @see {BitcoinDepositor#encodeExtraData}
   * @dev Packs the data to bytes32: 20 bytes of deposit owner address and 2 bytes of
   *      referral, 10 bytes of trailing zeros.
   */
  // eslint-disable-next-line class-methods-use-this
  encodeExtraData(depositOwner: ChainIdentifier, referral: number): Hex {
    const depositOwnerAddress = `0x${depositOwner.identifierHex}`

    if (!isAddress(depositOwnerAddress) || depositOwnerAddress === ZeroAddress)
      throw new Error("Invalid deposit owner address")

    const encodedData = solidityPacked(
      ["address", "uint16"],
      [depositOwnerAddress, referral],
    )

    return Hex.from(zeroPadBytes(encodedData, 32))
  }

  /**
   * @see {BitcoinDepositor#decodeExtraData}
   * @dev Unpacks the data from bytes32: 20 bytes of deposit owner address and 2
   *      bytes of referral, 10 bytes of trailing zeros.
   */
  // eslint-disable-next-line class-methods-use-this
  decodeExtraData(extraData: string): DecodedExtraData {
    const depositOwner = EthereumAddress.from(
      getAddress(dataSlice(extraData, 0, 20)),
    )
    const referral = Number(dataSlice(extraData, 20, 22))

    return { depositOwner, referral }
  }

  /**
   * @see {BitcoinDepositor#minDepositAmount}
   * @dev The value in tBTC token precision (1e18 precision).
   */
  async minDepositAmount(): Promise<bigint> {
    return this.instance.minDepositAmount()
  }

  /**
   * @see {BitcoinDepositor#calculateDepositFee}
   */
  async calculateDepositFee(amountToDeposit: bigint): Promise<DepositFees> {
    const {
      depositTreasuryFeeDivisor,
      depositTxMaxFee: depositTxMaxFeeInSatoshi,
      optimisticMintingFeeDivisor,
    } = await this.#getTbtcBridgeMintingParameters()

    const depositTxMaxFee = fromSatoshi(depositTxMaxFeeInSatoshi)

    const treasuryFee =
      depositTreasuryFeeDivisor > 0
        ? amountToDeposit / depositTreasuryFeeDivisor
        : 0n

    const amountSubTreasury = amountToDeposit - treasuryFee

    const optimisticMintingFee =
      optimisticMintingFeeDivisor > 0
        ? amountSubTreasury / optimisticMintingFeeDivisor
        : 0n

    const depositorFeeDivisor = await this.#depositorFeeDivisor()
    // Compute depositor fee. The fee is calculated based on the initial funding
    // transaction amount, before the tBTC protocol network fees were taken.
    const depositorFee =
      depositorFeeDivisor > 0n ? amountToDeposit / depositorFeeDivisor : 0n

    const bridgeFeesReimbursementThreshold =
      await this.bridgeFeesReimbursementThreshold()

    const areTbtcFeesReimbursable =
      bridgeFeesReimbursementThreshold > 0n &&
      bridgeFeesReimbursementThreshold >= amountToDeposit

    let reimbursableFee = 0n

    if (areTbtcFeesReimbursable) {
      const balanceOfReimbursementPool =
        await this.#getTbtcBalanceOfFeesReimbursementPool()

      const totalFee = treasuryFee + optimisticMintingFee + depositTxMaxFee

      reimbursableFee =
        balanceOfReimbursementPool > totalFee
          ? totalFee
          : balanceOfReimbursementPool
    }

    return {
      tbtc: {
        treasuryFee,
        optimisticMintingFee,
        depositTxMaxFee,
        reimbursableFee,
      },
      acre: {
        bitcoinDepositorFee: depositorFee,
      },
    }
  }

  // TODO: Consider exposing it from tBTC SDK.
  async #getTbtcBridgeMintingParameters(): Promise<TbtcBridgeMintingParameters> {
    if (this.#cache.tbtcBridgeMintingParameters) {
      return this.#cache.tbtcBridgeMintingParameters
    }

    if (!this.#tbtcBridge || !this.#tbtcVault) {
      throw new Error("tBTC contracts not set")
    }

    const { depositTreasuryFeeDivisor, depositTxMaxFee } =
      await this.#tbtcBridge.depositParameters()

    const optimisticMintingFeeDivisor =
      await this.#tbtcVault.optimisticMintingFeeDivisor()

    this.#cache.tbtcBridgeMintingParameters = {
      depositTreasuryFeeDivisor,
      depositTxMaxFee,
      optimisticMintingFeeDivisor,
    }
    return this.#cache.tbtcBridgeMintingParameters
  }

  async #depositorFeeDivisor(): Promise<bigint> {
    if (this.#cache.depositorFeeDivisor) {
      return this.#cache.depositorFeeDivisor
    }

    this.#cache.depositorFeeDivisor = await this.instance.depositorFeeDivisor()

    return this.#cache.depositorFeeDivisor
  }

  async #getTbtcBalanceOfFeesReimbursementPool() {
    if (!this.#tbtcToken) throw new Error("tBTC contracts not set")

    const feesReimbursementPool = await this.#getFeesReimbursementPool()

    if (feesReimbursementPool.equals(EthereumAddress.from(ZeroAddress)))
      return 0n

    return this.#tbtcToken.balanceOf(await this.#getFeesReimbursementPool())
  }

  async #getFeesReimbursementPool() {
    if (this.#cache.feesReimbursementPool) {
      return this.#cache.feesReimbursementPool
    }

    let feesReimbursementPool

    // Use try catch to check if the `BitcoinDepositor` contract has
    // `feesReimbursementPool` function. The contract has been updated on the
    // testnet but not on the mainnet, which is why we're using a try-catch.
    try {
      feesReimbursementPool = await this.instance.feesReimbursementPool()
    } catch (error) {
      feesReimbursementPool = ZeroAddress
    }

    this.#cache.feesReimbursementPool = EthereumAddress.from(
      feesReimbursementPool,
    )

    return this.#cache.feesReimbursementPool
  }

  async getTbtcBridgeAddress(): Promise<string> {
    return this.instance.bridge()
  }

  async getTbtcVaultAddress(): Promise<string> {
    return this.instance.tbtcVault()
  }

  async getTbtcTokenAddress(): Promise<string> {
    return this.instance.tbtcToken()
  }

  /**
   * @see {BitcoinDepositor#bridgeFeesReimbursementThreshold}
   */
  async bridgeFeesReimbursementThreshold(): Promise<bigint> {
    // Use try catch to check if the `BitcoinDepositor` contract has
    // `bridgeFeesReimbursementThreshold` function. The contract has been
    // updated on the testnet but not on the mainnet, which is why we're using a
    // try-catch.
    try {
      return await this.instance.bridgeFeesReimbursementThreshold()
    } catch (error) {
      return 0n
    }
  }
}

export { EthereumBitcoinDepositor, packRevealDepositParameters }
