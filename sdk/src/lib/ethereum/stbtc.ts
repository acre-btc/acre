import { StBTC as StBTCTypechain } from "@acre-btc/contracts/typechain/contracts/StBTC"
import stBTC from "@acre-btc/contracts/deployments/sepolia/stBTC.json"

import {
  EthersContractConfig,
  EthersContractDeployment,
  EthersContractWrapper,
} from "./contract"
import { ChainIdentifier, StBTC } from "../contracts"
import { EthereumNetwork } from "./network"
import { Hex } from "../utils"

class EthereumStBTC
  // @ts-expect-error TODO: Figure out why type generated by typechain does not
  // satisfy the constraint `Contract`. Error: `Property '[internal]' is missing
  // in type 'StBTC' but required in type 'BaseContract'`.
  extends EthersContractWrapper<StBTCTypechain>
  implements StBTC
{
  readonly #BASIS_POINT_SCALE = BigInt(1e4)

  #cache: {
    entryFeeBasisPoints?: bigint
    exitFeeBasisPoints?: bigint
  } = { entryFeeBasisPoints: undefined, exitFeeBasisPoints: undefined }

  constructor(config: EthersContractConfig, network: EthereumNetwork) {
    let artifact: EthersContractDeployment

    switch (network) {
      case "sepolia":
        artifact = stBTC
        break
      case "mainnet":
      default:
        throw new Error("Unsupported network")
    }

    super(config, artifact)
  }

  /**
   * @see {StBTC#getChainIdentifier}
   */
  getChainIdentifier(): ChainIdentifier {
    return this.getAddress()
  }

  /**
   * @see {StBTC#totalAssets}
   */
  totalAssets(): Promise<bigint> {
    return this.instance.totalAssets()
  }

  /**
   * @see {StBTC#balanceOf}
   */
  balanceOf(identifier: ChainIdentifier): Promise<bigint> {
    return this.instance.balanceOf(`0x${identifier.identifierHex}`)
  }

  /**
   * @see {StBTC#assetsBalanceOf}
   */
  assetsBalanceOf(identifier: ChainIdentifier): Promise<bigint> {
    return this.instance.assetsBalanceOf(`0x${identifier.identifierHex}`)
  }

  /**
   * @see {StBTC#calculateDepositFee}
   */
  async calculateDepositFee(amount: bigint): Promise<bigint> {
    const entryFeeBasisPoints = await this.#getEntryFeeBasisPoints()

    return this.#feeOnTotal(amount, entryFeeBasisPoints)
  }

  /**
   * @see {StBTC#calculateDepositFee}
   */
  async calculateWithdrawalFee(amount: bigint): Promise<bigint> {
    const exitFeeBasisPoints = await this.#getExitFeeBasisPoints()

    return this.#feeOnTotal(amount, exitFeeBasisPoints)
  }

  async #getEntryFeeBasisPoints(): Promise<bigint> {
    if (this.#cache.entryFeeBasisPoints) {
      return this.#cache.entryFeeBasisPoints
    }

    this.#cache.entryFeeBasisPoints = await this.instance.entryFeeBasisPoints()

    return this.#cache.entryFeeBasisPoints
  }

  async #getExitFeeBasisPoints(): Promise<bigint> {
    if (this.#cache.exitFeeBasisPoints) {
      return this.#cache.exitFeeBasisPoints
    }

    this.#cache.exitFeeBasisPoints = await this.instance.exitFeeBasisPoints()

    return this.#cache.exitFeeBasisPoints
  }

  /**
   * @see {StBTC#encodeApproveAndCallFunctionData}
   */
  encodeApproveAndCallFunctionData(
    spender: ChainIdentifier,
    shares: bigint,
    extraData: Hex,
  ): Hex {
    const data = this.instance.interface.encodeFunctionData("approveAndCall", [
      `0x${spender.identifierHex}`,
      shares,
      extraData.toPrefixedString(),
    ])

    return Hex.from(data)
  }

  /**
   * @see {StBTC#previewRedeem}
   */
  previewRedeem(shares: bigint): Promise<bigint> {
    return this.instance.previewRedeem(shares)
  }

  /**
   * @see {StBTC#convertToShares}
   */
  convertToShares(amount: bigint): Promise<bigint> {
    return this.instance.convertToShares(amount)
  }

  /**
   * Calculates the fee when it's included in the amount.
   * One is added to the result if there is a remainder to match the stBTC
   * contract calculations rounding.
   * @param amount Amount in tBTC
   * @param feeBasisPoints Fee basis points applied to calculate the fee.
   * @returns The fee part of an amount that already includes fees.
   */
  #feeOnTotal(amount: bigint, feeBasisPoints: bigint) {
    const result =
      (amount * feeBasisPoints) / (feeBasisPoints + this.#BASIS_POINT_SCALE)
    if (
      (amount * feeBasisPoints) % (feeBasisPoints + this.#BASIS_POINT_SCALE) >
      0
    ) {
      return result + 1n
    }
    return result
  }
}

// eslint-disable-next-line import/prefer-default-export
export { EthereumStBTC }
